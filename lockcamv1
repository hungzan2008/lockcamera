local fov = 25 -- üéØ K√≠ch th∆∞·ªõc h√¨nh tr√≤n (c√≥ th·ªÉ ch·ªânh)
local FOVEnabled = false -- Tr·∫°ng th√°i Aimlock (t·∫Øt m·∫∑c ƒë·ªãnh)

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Cam = game.Workspace.CurrentCamera

-- üìå T·∫°o GUI
local ScreenGui = Instance.new("ScreenGui", game.CoreGui)
local AimButton = Instance.new("TextButton", ScreenGui)
local DragFrame = Instance.new("Frame", ScreenGui)

-- üîò C√†i ƒë·∫∑t n√∫t ON/OFF
AimButton.Size = UDim2.new(0, 100, 0, 50)
AimButton.Position = UDim2.new(0.8, 0, 0.8, 0)
AimButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
AimButton.Text = "OFF"
AimButton.TextSize = 20
AimButton.TextColor3 = Color3.fromRGB(255, 255, 255)
AimButton.Font = Enum.Font.SourceSansBold
AimButton.BorderSizePixel = 2
AimButton.BorderColor3 = Color3.fromRGB(255, 255, 255)
AimButton.Parent = ScreenGui
AimButton.Draggable = true -- K√©o n√∫t ƒëi b·∫•t k·ª≥ ƒë√¢u

-- üìå T·∫°o v√πng k√©o GUI
DragFrame.Size = UDim2.new(0, 100, 0, 50)
DragFrame.Position = AimButton.Position
DragFrame.BackgroundTransparency = 1
DragFrame.Draggable = true -- Cho ph√©p k√©o
DragFrame.Parent = ScreenGui

-- üéØ V√≤ng tr√≤n ngo√†i (Vi·ªÅn)
local OuterFOV = Drawing.new("Circle")
OuterFOV.Visible = false
OuterFOV.Thickness = 5 -- üî• ƒê·ªô d√†y vi·ªÅn
OuterFOV.Color = Color3.fromRGB(128, 0, 128) -- üé® M√†u t√≠m
OuterFOV.Filled = true -- ƒê·ªÉ t·∫°o vi·ªÅn
OuterFOV.Transparency = 1
OuterFOV.Radius = fov + 2 -- To h∆°n m·ªôt ch√∫t ƒë·ªÉ t·∫°o vi·ªÅn
OuterFOV.Position = Cam.ViewportSize / 2

-- üéØ V√≤ng tr√≤n trong (L√†m r·ªóng)
local InnerFOV = Drawing.new("Circle")
InnerFOV.Visible = false
InnerFOV.Thickness = 1
InnerFOV.Color = Color3.fromRGB(0, 0, 0) -- C√πng m√†u v·ªõi n·ªÅn ƒë·ªÉ l√†m r·ªóng
InnerFOV.Filled = true
InnerFOV.Transparency = 1
InnerFOV.Radius = fov -- Nh·ªè h∆°n v√≤ng tr√≤n ngo√†i
InnerFOV.Position = Cam.ViewportSize / 2

-- üîç T√¨m ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t trong FOV
local function getClosestPlayerInFOV(trg_part)
    local nearest = nil
    local last = math.huge
    local playerMousePos = Cam.ViewportSize / 2

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            local part = player.Character and player.Character:FindFirstChild(trg_part)
            if part then
                local ePos, isVisible = Cam:WorldToViewportPoint(part.Position)
                local distance = (Vector2.new(ePos.x, ePos.y) - playerMousePos).Magnitude

                if distance < last and isVisible and distance < fov then
                    last = distance
                    nearest = player
                end
            end
        end
    end
    return nearest
end

-- üìå B·∫≠t/t·∫Øt Aimlock b·∫±ng n√∫t
AimButton.MouseButton1Click:Connect(function()
    FOVEnabled = not FOVEnabled

    if FOVEnabled then
        OuterFOV.Visible = true
        InnerFOV.Visible = true
        AimButton.Text = "ON"
        AimButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    else
        OuterFOV.Visible = false
        InnerFOV.Visible = false
        AimButton.Text = "OFF"
        AimButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    end
end)

-- üîÑ C·∫≠p nh·∫≠t v·ªã tr√≠ h√¨nh tr√≤n FOV & Aimlock
RunService.RenderStepped:Connect(function()
    OuterFOV.Position = Cam.ViewportSize / 2
    InnerFOV.Position = Cam.ViewportSize / 2

    if FOVEnabled then
        local closest = getClosestPlayerInFOV("Head")
        if closest and closest.Character:FindFirstChild("Head") then
            local lookVector = (closest.Character.Head.Position - Cam.CFrame.Position).unit
            Cam.CFrame = CFrame.new(Cam.CFrame.Position, Cam.CFrame.Position + lookVector)
        end
    end
end)

-- üìå K√©o GUI ƒë·∫øn v·ªã tr√≠ kh√°c
local dragging, dragInput, dragStart, startPos

DragFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = DragFrame.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

DragFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

RunService.RenderStepped:Connect(function()
    if dragging and dragInput then
        local delta = dragInput.Position - dragStart
        DragFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        AimButton.Position = DragFrame.Position -- Di chuy·ªÉn n√∫t theo
    end
